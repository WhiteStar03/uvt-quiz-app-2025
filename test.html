<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Taking Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
            padding: 40px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: fadeIn 0.6s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Category Selection Screen */
        .category-selection {
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Smaller minmax */
            gap: 15px; /* Reduced gap */
            margin-top: 25px;
        }

        .category-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px; /* Slightly smaller */
            padding: 20px; /* Reduced padding */
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .category-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
        }

        .category-card h3 {
            color: #333;
            margin-bottom: 8px; /* Reduced margin */
            font-size: 1.2em; /* Smaller font */
        }

        .category-card p {
            color: #666;
            font-size: 0.85em; /* Smaller font */
        }


        /* Test Screen */
        .test-screen {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .progress-bar {
            background: #e0e0e0;
            height: 8px;
            border-radius: 4px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .question-container {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .question-number {
            color: #667eea;
            font-weight: bold;
            font-size: 1.2em;
        }

        .question-text {
            color: #333;
            font-size: 1.2em;
            line-height: 1.6;
            margin-bottom: 25px;
            white-space: pre-wrap; /* Preserve newlines and spaces for code blocks */
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .option {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .option:hover:not(.disabled-option) { /* Only hover if not disabled for feedback */
            border-color: #667eea;
            transform: translateX(5px);
        }

        .option.selected:not(.correct-selection):not(.incorrect-selection):not(.reveal-correct) { /* Base selection style, overridden by feedback */
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option input[type="checkbox"],
        .option input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #667eea;
        }
        
        .option input[type="checkbox"]:disabled,
        .option input[type="radio"]:disabled {
            cursor: not-allowed;
        }
        .option.disabled-option {
            cursor: not-allowed;
        }
        .option.disabled-option:hover { /* Prevent hover effects when disabled */
             transform: none;
             /* Keep feedback border colors on hover when disabled */
             border-color: #e0e0e0; /* Default disabled border */
        }
        .option.disabled-option.correct-selection:hover,
        .option.disabled-option.reveal-correct.correct-selection:hover { border-color: #5cb85c !important; }
        .option.disabled-option.incorrect-selection:hover { border-color: #d9534f !important; }
        .option.disabled-option.reveal-correct:not(.correct-selection):hover { border-color: #28a745 !important; }


        .option-text {
            flex: 1;
            color: #333;
        }

        /* Feedback Styles */
        .option.correct-selection { /* User selected this AND it was correct */
            background-color: #e6ffed !important;
            border-color: #5cb85c !important;
        }
        .option.incorrect-selection { /* User selected this AND it was incorrect */
            background-color: #ffe6e6 !important;
            border-color: #d9534f !important;
        }
        .option.reveal-correct { /* This was a correct answer (whether user selected or not) */
            border-color: #28a745 !important; /* Green border for all correct options */
        }
        .option.reveal-correct:not(.correct-selection) { /* A correct answer user missed */
             background-color: #f0fff0 !important; /* Very light green for missed correct */
        }


        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            gap: 20px;
        }

        .nav-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 30px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .nav-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .nav-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .nav-button.secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .nav-button.secondary:hover:not(:disabled) {
            background: #f0f4ff;
        }

        /* Results Screen */
        .results-screen {
            display: none;
            text-align: center;
            animation: fadeIn 0.5s ease;
        }

        .score-circle {
            width: 200px;
            height: 200px;
            margin: 30px auto;
            position: relative;
        }

        .score-circle svg {
            transform: rotate(-90deg);
        }

        .score-circle-bg {
            fill: none;
            stroke: #e0e0e0;
            stroke-width: 15;
        }

        .score-circle-progress {
            fill: none;
            stroke: url(#gradient);
            stroke-width: 15;
            stroke-linecap: round;
            transition: stroke-dashoffset 1s ease;
        }

        .score-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: bold;
            color: #667eea;
        }

        .results-summary {
            margin: 30px 0;
            font-size: 1.2em;
            color: #666;
        }

        .answer-review {
            margin-top: 40px;
            text-align: left;
        }

        .review-question {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .review-question.incorrect {
            border-left-color: #e74c3c;
        }

        .review-question.correct {
            border-left-color: #27ae60;
        }

        .correct-answer { /* Style for text spans in review */
            color: #27ae60;
            font-weight: 600;
        }

        .incorrect-answer {  /* Style for text spans in review */
            color: #e74c3c;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            color: #666;
            font-size: 1.2em;
            padding: 40px;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 2em;
            }

            .category-grid {
                grid-template-columns: 1fr;
            }

            .navigation {
                flex-direction: column;
            }

            .nav-button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Knowledge Assessment Platform</h1>

        <!-- Category Selection Screen -->
        <div class="category-selection" id="categoryScreen">
            <h2 style="text-align: center; color: #666; margin-bottom: 20px;">Select a Subtopic</h2>
            <div class="category-grid" id="categoryGrid">
                <div class="loading">Loading categories...</div>
            </div>
        </div>

        <!-- Test Screen -->
        <div class="test-screen" id="testScreen">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div class="question-container">
                <div class="question-header">
                    <span class="question-number" id="questionNumber"></span>
                    <span style="color: #666;" id="categoryName"></span>
                </div>
                <div class="question-text" id="questionText"></div>
                <div class="options" id="optionsContainer"></div>
            </div>

            <div class="navigation">
                <button class="nav-button secondary" id="prevButton" onclick="previousQuestion()">Previous</button>
                <span style="color: #666;" id="questionStatus"></span>
                <button class="nav-button" id="nextButton">Next</button> <!-- onclick handled dynamically -->
            </div>
        </div>

        <!-- Results Screen -->
        <div class="results-screen" id="resultsScreen">
            <h2 style="color: #333; margin-bottom: 30px;">Test Complete!</h2>

            <div class="score-circle">
                <svg width="200" height="200">
                    <defs>
                        <linearGradient id="gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <circle cx="100" cy="100" r="85" class="score-circle-bg"></circle>
                    <circle cx="100" cy="100" r="85" class="score-circle-progress" id="scoreCircle"></circle>
                </svg>
                <div class="score-text" id="scoreText">0%</div>
            </div>

            <div class="results-summary" id="resultsSummary"></div>

            <button class="nav-button" onclick="showReview()">Review Answers</button>
            <button class="nav-button secondary" onclick="resetTest()">Take Another Test</button>

            <div class="answer-review" id="answerReview" style="display: none;"></div>
        </div>
    </div>

    <script>
        let fullQuestionsData = null;
        let displayableCategories = [];
        let currentCategory = null;
        let currentQuestionIndex = 0;
        let userAnswers = {};
        let testStartTime = null;
        let isFeedbackMode = false; // True if feedback is currently shown for a question

        async function loadTestData() {
           try {
             // For local testing, create a dummy questions.json or replace this path
             const res = await fetch('questions.json'); // Ensure this file exists in the same directory or provide correct path
             if (!res.ok) {
                 const errorMsg = `Failed to fetch questions.json: HTTP ${res.status} ${res.statusText}`;
                 console.error(errorMsg);
                 document.getElementById('categoryGrid').innerHTML = `<div class="error">${errorMsg}. Please ensure questions.json is accessible.</div>`;
                 throw new Error(`HTTP error! status: ${res.status}`);
             }
             fullQuestionsData = await res.json();

             if (!fullQuestionsData || typeof fullQuestionsData.exam !== 'object' || !Array.isArray(fullQuestionsData.exam.topics)) {
                const errorMsg = 'Loaded questions data is not in the expected format (exam.topics is missing or not an array).';
                console.error(errorMsg, fullQuestionsData);
                document.getElementById('categoryGrid').innerHTML = `<div class="error">${errorMsg} Check console.</div>`;
                return;
             }

             displayableCategories = [];
             fullQuestionsData.exam.topics.forEach(topic => {
                 if (topic.subtopics && Array.isArray(topic.subtopics)) {
                     topic.subtopics.forEach(subtopic => {
                         if (subtopic && typeof subtopic.subtopic_name === 'string' && Array.isArray(subtopic.questions)) {
                             displayableCategories.push({
                                 ...subtopic,
                                 parent_topic_name: topic.topic_name
                             });
                         } else {
                             console.warn('Skipping malformed subtopic:', subtopic, 'under topic:', topic.topic_name);
                         }
                     });
                 }
             });

             if (displayableCategories.length === 0) {
                document.getElementById('categoryGrid').innerHTML = '<div class="loading">No test categories found in the provided data.</div>';
                return;
             }
             displayCategories(displayableCategories);
           } catch (err) {
             console.error('Error loading or processing questions.json:', err);
             const grid = document.getElementById('categoryGrid');
             if (grid) {
                grid.innerHTML = `<div class="error">Failed to load categories: ${err.message}. Check console.</div>`;
             }
           }
         }

        function displayCategories(subtopicsToDisplay) {
            const grid = document.getElementById('categoryGrid');
            grid.innerHTML = '';

            if (!subtopicsToDisplay || subtopicsToDisplay.length === 0) {
                grid.innerHTML = '<div class="loading">No categories to display.</div>';
                return;
            }

            subtopicsToDisplay.forEach((subtopic, index) => {
                const card = document.createElement('div');
                card.className = 'category-card';
                card.onclick = () => startTest(index);

                const questionCount = subtopic.questions.length;
                card.innerHTML = `
                <h3>${subtopic.subtopic_name}</h3>
                ${subtopic.parent_topic_name ? `<p style="font-size:0.8em; color:#555; margin-top: 5px;"><em>Topic: ${subtopic.parent_topic_name}</em></p>` : ''}
                <p style="margin-top: 10px;">${questionCount} question${questionCount !== 1 ? 's' : ''}</p>
                `;
                grid.appendChild(card);
            });
        }

        function startTest(subtopicIndex) {
            currentCategory = displayableCategories[subtopicIndex];
            if (!currentCategory || !currentCategory.questions || currentCategory.questions.length === 0) {
                alert("This category has no questions or is invalid. Please select another.");
                return;
            }
            currentQuestionIndex = 0;
            userAnswers = {};
            testStartTime = new Date();
            isFeedbackMode = false;

            document.getElementById('categoryScreen').style.display = 'none';
            document.getElementById('testScreen').style.display = 'block';
            document.getElementById('resultsScreen').style.display = 'none';


            let categoryDisplayName = currentCategory.subtopic_name;
            document.getElementById('categoryName').textContent = `Subtopic: ${categoryDisplayName}`;
            displayQuestion();
        }

        function displayQuestion() {
            const question = currentCategory.questions[currentQuestionIndex];
            const totalQuestions = currentCategory.questions.length;

            const progress = ((currentQuestionIndex + 1) / totalQuestions) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;

            document.getElementById('questionNumber').textContent = `Question ${currentQuestionIndex + 1} of ${totalQuestions}`;
            document.getElementById('questionText').textContent = question.question_text;
            document.getElementById('questionStatus').textContent = `${currentQuestionIndex + 1} / ${totalQuestions}`;

            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = '';
            const isMultipleChoice = question.correct_answers.length > 1;

            question.options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                const savedAnswers = userAnswers[question.question_id] || [];
                const isChecked = savedAnswers.includes(option.id);

                const inputId = `option_${question.question_id}_${option.id}`;
                optionDiv.innerHTML = `
                    <input type="${isMultipleChoice ? 'checkbox' : 'radio'}"
                           name="question_${question.question_id}" 
                           value="${option.id}"
                           id="${inputId}"
                           ${isChecked ? 'checked' : ''}
                           onchange="selectAnswer('${option.id}', ${isMultipleChoice})">
                    <label for="${inputId}" class="option-text">${option.id}. ${option.text}</label>
                `;

                if (isChecked) optionDiv.classList.add('selected');
                
                optionDiv.onclick = function(e) {
                    if (isFeedbackMode) return; 

                    const target = e.target;
                    const input = this.querySelector('input');
                    if (!input) return;

                    if (target.tagName.toLowerCase() !== 'input' && target.tagName.toLowerCase() !== 'label') {
                        // Click on div area
                        if (input.type === 'radio' && input.checked) return; // Don't uncheck radio by div click
                        input.checked = !input.checked;
                    } else if (target.tagName.toLowerCase() === 'label') {
                        // Click on label
                        if (input.type === 'radio' && input.checked) return; // Don't uncheck radio by label click
                        // For checkboxes, or unselected radios, the default label behavior is fine.
                        // If we want to force toggle for label always (even radios):
                        // input.checked = !input.checked;
                    }
                    // Manually trigger change event if not already triggered or to ensure consistency
                    const event = new Event('change', { bubbles: true });
                    input.dispatchEvent(event);
                };
                optionsContainer.appendChild(optionDiv);
            });
            
            isFeedbackMode = false; 
            
            const nextButton = document.getElementById('nextButton');
            const prevButton = document.getElementById('prevButton');
            prevButton.disabled = currentQuestionIndex === 0;

            if (currentQuestionIndex === totalQuestions - 1) {
                nextButton.textContent = 'Finish';
                nextButton.onclick = handleFinishClick;
            } else {
                nextButton.textContent = 'Next';
                nextButton.onclick = handleNextClick;
            }
        }

        function selectAnswer(optionId, isMultipleChoice) {
            if (isFeedbackMode) return; 

            const question = currentCategory.questions[currentQuestionIndex];
            const questionId = question.question_id;

            if (isMultipleChoice) {
                if (!userAnswers[questionId]) userAnswers[questionId] = [];
                const index = userAnswers[questionId].indexOf(optionId);
                if (index > -1) userAnswers[questionId].splice(index, 1);
                else userAnswers[questionId].push(optionId);
            } else {
                userAnswers[questionId] = [optionId];
            }

            document.querySelectorAll(`#optionsContainer .option`).forEach(optDiv => {
                const input = optDiv.querySelector('input');
                if (input.checked) optDiv.classList.add('selected');
                else optDiv.classList.remove('selected');
            });
        }

        function showAnswerFeedback() {
            const question = currentCategory.questions[currentQuestionIndex];
            const userSelection = userAnswers[question.question_id] || [];
            const correctAnswers = question.correct_answers;

            document.querySelectorAll('#optionsContainer .option').forEach(optDiv => {
                const input = optDiv.querySelector('input');
                input.disabled = true;
                optDiv.classList.add('disabled-option');
                // optDiv.onclick = null; // Further prevent div clicks from attempting changes

                const optionId = input.value;
                const isCorrect = correctAnswers.includes(optionId);
                const isSelected = userSelection.includes(optionId);

                if (isCorrect) { 
                    optDiv.classList.add('reveal-correct');
                }
                if (isSelected) { 
                    if (isCorrect) {
                        optDiv.classList.add('correct-selection');
                    } else {
                        optDiv.classList.add('incorrect-selection');
                    }
                }
            });
            document.getElementById('prevButton').disabled = true; 
        }

        function handleNextClick() {
            const nextButton = document.getElementById('nextButton');
            if (isFeedbackMode) { 
                isFeedbackMode = false;
                currentQuestionIndex++;
                displayQuestion(); 
            } else { 
                showAnswerFeedback();
                isFeedbackMode = true;
                nextButton.textContent = 'Continue';
            }
        }

        function handleFinishClick() {
            const nextButton = document.getElementById('nextButton');
            if (isFeedbackMode) { 
                finishTest();
            } else { 
                showAnswerFeedback();
                isFeedbackMode = true; 
                nextButton.textContent = 'View Results';
            }
        }

        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                isFeedbackMode = false; 
                currentQuestionIndex--;
                displayQuestion(); 
            }
        }
        
        function finishTest() {
            const testEndTime = new Date();
            const timeTaken = Math.floor((testEndTime - testStartTime) / 1000);
            let correctCount = 0;
            const totalQuestions = currentCategory.questions.length;

            currentCategory.questions.forEach(question => {
                const userAnswer = userAnswers[question.question_id] || [];
                const correctAnswer = question.correct_answers;
                const sortedUserAnswer = [...userAnswer].sort();
                const sortedCorrectAnswer = [...correctAnswer].sort();
                if (sortedUserAnswer.length === sortedCorrectAnswer.length &&
                    sortedUserAnswer.every((val, index) => val === sortedCorrectAnswer[index])) {
                    correctCount++;
                }
            });

            const score = totalQuestions > 0 ? Math.round((correctCount / totalQuestions) * 100) : 0;

            document.getElementById('testScreen').style.display = 'none';
            document.getElementById('resultsScreen').style.display = 'block';

            const circumference = 2 * Math.PI * 85;
            const scoreCircleEl = document.getElementById('scoreCircle');
            scoreCircleEl.style.strokeDasharray = circumference;
            scoreCircleEl.style.strokeDashoffset = circumference;
            setTimeout(() => {
                scoreCircleEl.style.strokeDashoffset = circumference - (score / 100) * circumference;
                document.getElementById('scoreText').textContent = `${score}%`;
            }, 100);

            const minutes = Math.floor(timeTaken / 60);
            const seconds = timeTaken % 60;
            let summaryHTML = `
                <p>You answered <strong>${correctCount}</strong> out of <strong>${totalQuestions}</strong> questions correctly.</p>
                <p>Time taken: <strong>${minutes}m ${seconds}s</strong></p>
                <p>Subtopic: <strong>${currentCategory.subtopic_name}</strong></p>`;
            if (currentCategory.parent_topic_name) {
                summaryHTML += `<p>Topic: <strong>${currentCategory.parent_topic_name}</strong></p>`;
            }
            document.getElementById('resultsSummary').innerHTML = summaryHTML;
            prepareReview();
        }

        function prepareReview() {
            const reviewContainer = document.getElementById('answerReview');
            reviewContainer.innerHTML = '<h3 style="margin-bottom: 20px;">Answer Review</h3>';
            currentCategory.questions.forEach((question, index) => {
                const userAnswer = userAnswers[question.question_id] || [];
                const correctAnswer = question.correct_answers;
                const sortedUserAnswer = [...userAnswer].sort();
                const sortedCorrectAnswer = [...correctAnswer].sort();
                const isOverallCorrect = sortedUserAnswer.length === sortedCorrectAnswer.length &&
                                 sortedUserAnswer.every((val, i) => val === sortedCorrectAnswer[i]);

                const reviewDiv = document.createElement('div');
                reviewDiv.className = `review-question ${isOverallCorrect ? 'correct' : 'incorrect'}`;
                
                let optionsHtml = question.options.map(opt => {
                    const isUserSelectedOpt = userAnswer.includes(opt.id);
                    const isCorrectOpt = correctAnswer.includes(opt.id);
                    
                    let optFeedbackClass = '';
                    let optFeedbackText = '';

                    if (isCorrectOpt) {
                        optFeedbackText += ' <span class="correct-answer">(Correct Answer)</span>';
                    }
                    if (isUserSelectedOpt) {
                        if (isCorrectOpt) {
                            optFeedbackClass = 'correct-answer'; // User chose this, and it's correct
                            optFeedbackText += ' <span class="correct-answer">(Your Choice)</span>';
                        } else {
                            optFeedbackClass = 'incorrect-answer'; // User chose this, and it's wrong
                            optFeedbackText += ' <span class="incorrect-answer">(Your Choice)</span>';
                        }
                    }
                    return `<div class="${optFeedbackClass}">${opt.id}. ${opt.text} ${optFeedbackText}</div>`;
                }).join('');

                reviewDiv.innerHTML = `
                    <h4>Question ${index + 1}: <span style="white-space: pre-wrap;">${question.question_text}</span></h4>
                    <p><strong>Your answer(s):</strong> ${userAnswer.length > 0 ? userAnswer.join(', ') : 'Not answered'}</p>
                    <p><strong>Correct answer(s):</strong> ${correctAnswer.join(', ')}</p>
                    <div style="margin-top: 10px;">${optionsHtml}</div>
                    <p style="margin-top: 5px;"><strong>Explanation:</strong> ${question.explanation || 'No explanation provided.'}</p>
                `;
                reviewContainer.appendChild(reviewDiv);
            });
        }

        function showReview() {
            const review = document.getElementById('answerReview');
            review.style.display = review.style.display === 'none' ? 'block' : 'none';
        }

        function resetTest() {
            document.getElementById('resultsScreen').style.display = 'none';
            document.getElementById('categoryScreen').style.display = 'block';
            document.getElementById('answerReview').style.display = 'none';
            currentQuestionIndex = 0;
            userAnswers = {};
            currentCategory = null;
            isFeedbackMode = false;
            // To re-fetch categories and questions from server:
            // loadTestData(); 
            // Or, if categories don't change often, just reset to category screen.
        }

        window.onload = loadTestData;
    </script>
</body>
</html>